
关键词：
* 权限信息


用户登录时，在 AuthInterceptor 登录并获取其 权限信息：用户基本信息、角色、权限.
同时为了支持超级管理员，在入口的鉴权拦截器检测到是 admin 时，就扫描全部权限并添加给 admin 用户。
在这里可以使用缓存权限来加速，但这样会有缓存一致性问题。

用户登录后，访问 url，在 AuthInterceptor 登录，然后将其 权限信息 持久化到 request 的 scope 中
> 这里如果使用 jwt 那就是解析 jwtToken 然后持久化到 request 的 scope 中
> 如果是 session 那就是解析 token 然后持久化到 request 的 scope 中


做权限判断时，一根据 角色 来取到 该角色的权限表 然后在根据权限表有没有这个 权限 来进行判断
权限表达式可以自己设计，一般从左至右是从大到小的顺序，比如 模块:功能:CURD、菜单:按钮:CRUD
这样权限表达式就会被区分为好几种，使用时要注意区分。

Rbac0 其权限是由关联表来赋予的，比如要赋予某个角色权限时只需要更新 角色权限关联表 即可
用户登录，查询该用户所持有的角色，根据角色去取该用户所持有的权限表达式，返回角色跟权限表达式。
前端得到角色跟权限表达式，可以使用 hasRole hasPermission 来决定是否能够访问资源
权限往往有两层，第一层是资源的可见性这个是由于前后端带来的，以前模板引擎是不会有这个的
第二层是资源的 crud，这个是真正的后端权限，决定了该角色能对这个资源做什么
由 第一层 跟 第二层 我们就能得出一个有趣的问题，那就是如果只在前端实现了安全性会怎样？
也就是不想前后端都实现一遍对资源的 curd 判断，只在前端做了显示不显示的判断，那样就会导致安全问题




# 邻接表实现的 父子继承关系，
# 其实相当于单链表，使用时取全局 parent_role_id 为 null 的值然后将其 role 作为 where parent_role_id=role 条件递归往下查
# 一直查到符合条件的值数量为 0，就算是查找完了整个继承关系
# 将结果全部放到 list 中，这样从 0~end 的遍历中就能构造出树了




# 组的概念分两种，一种角色组。一种用户组，都是为了批量分配权限而诞生的方便产物
# 方便产物，要看方便在何处，组的概念方便在于其自动化上：
# 比如 windows 上的权限组，某用户需要 admin 权限时，是将自己加入到 administrator 的组里面，这个组内的用户将会自动获得 admin 权限
# 再比如有几十个角色，需要赋给 几百个人，这时候就可以将这些角色编成一个角色组，加到这个角色组中的用户都自动获得这个组里全部的权限
# 使用用户组是，是将某个角色的权限赋给这个组里面的所有人，比如省行用户组内的所有用户自动获得 admin 权限
# 由上面我们可以开始设计表
# 自动行为需要一个 trigger 的时机，最好只在 role_group_admin、role、user 三个表发生 增删改 的时候，会自动的检查 三个表
# 对于 role 的删、改要涉及到 role_group_admin.roles 的删、改
# 对于 user 的删、改要涉及到  role_group_admin.users 的删、改
# role_group_admin 内 roles、users 的增删改都要求 检查对于的 role、user 表是否存在对应值
# 注意 角色组 跟 用户组 其实可以使用一种表来表达，但是为了简单的区分，最好有不同的名字，也不要混用
# 角色组跟用户组主要体现在操作思路流程的不同上，角色组先建立一堆角色的集合，然后在考虑加入用户，用户组则相反。
# 这两种场景都十分常见，并且不是任何操作者都可以立刻意识到二者的一致性，操作人只是往往是想给一堆用户进行分组，或者想给一堆角色进行分组开始思考的，因此最好区分开来
# 区分开来的两种表正好直接等于两种常见思路，而不需要任何的转换。
# 注意 组 不会影响到继承树的权限，是独立计算的，比如 b 继承自 a，a 加入了 admin 的权限组，b 不会因此获得任何变更。
# 如果是给 a 的 角色用户关联表 添加了 admin 权限，那么 b 就会因为继承关系获得 admin



菜单树的设计：
菜单本质上是一个树的概念，表达一棵树可以使用很多种方法，由于菜单树几乎不更新，增删改是很少的，这里采用 ClosureTable 的实现方式。
既然表达是结构是树的话，就要考虑一下是支持多棵树还是单颗树，这里的根节点菜单可能有很多个，因此支持多棵树是比较好的。
支持多棵树的话，就要有区分多棵树根节点的方法，同时还要标示出那些节点属于那颗树。

使用 type 来区分是否为根节点，
type=l1:menu:

因此我

current，取当前节点下一级时，current 相当于 parent：where parent=current and deepth=1
取上一级时 current 相当于 child：where child=current and deepth=1




