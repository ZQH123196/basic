关键词：
* 权限信息


用户登录时，在 AuthInterceptor 登录并获取其 权限信息：用户基本信息、角色、权限.
同时为了支持超级管理员，在入口的鉴权拦截器检测到是 admin 时，就扫描全部权限并添加给 admin 用户。
在这里可以使用缓存权限来加速，但这样会有缓存一致性问题。

用户登录后，访问 url，在 AuthInterceptor 登录，然后将其 权限信息 持久化到 request 的 scope 中
> 这里如果使用 jwt 那就是解析 jwtToken 然后持久化到 request 的 scope 中
> 如果是 session 那就是解析 token 然后持久化到 request 的 scope 中


做权限判断时，一根据 角色 来取到 该角色的权限表 然后在根据权限表有没有这个 权限 来进行判断
权限表达式可以自己设计，一般从左至右是从大到小的顺序，比如 模块:功能:CURD、菜单:按钮:CRUD
这样权限表达式就会被区分为好几种，使用时要注意区分。

Rbac0 其权限是由关联表来赋予的，比如要赋予某个角色权限时只需要更新 角色权限关联表 即可
用户登录，查询该用户所持有的角色，根据角色去取该用户所持有的权限表达式，返回角色跟权限表达式。
前端得到角色跟权限表达式，可以使用 hasRole hasPermission 来决定是否能够访问资源
权限往往有两层，第一层是资源的可见性这个是由于前后端带来的，以前模板引擎是不会有这个的
第二层是资源的 crud，这个是真正的后端权限，决定了该角色能对这个资源做什么
由 第一层 跟 第二层 我们就能得出一个有趣的问题，那就是如果只在前端实现了安全性会怎样？
也就是不想前后端都实现一遍对资源的 curd 判断，只在前端做了显示不显示的判断，那样就会导致安全问题

Spring Security 的设计里，用户和角色都可以拥有权限，譬如在它的 HttpSecurity 接口就同时有着 hasRole()和 hasAuthority()方法，可能刚接触的程序员会疑惑，混淆它们之间的关系。Spring Security 的访问控制模型如图 5-6 所示，可与前面 RBAC 的关系图对比一下。


# 邻接表实现的 父子继承关系，
# 其实相当于单链表，使用时取全局 parent_role_id 为 null 的值然后将其 role 作为 where parent_role_id=role 条件递归往下查
# 一直查到符合条件的值数量为 0，就算是查找完了整个继承关系
# 将结果全部放到 list 中，这样从 0~end 的遍历中就能构造出树了




# 组的概念分两种，一种角色组。一种用户组，都是为了批量分配权限而诞生的方便产物
# 方便产物，要看方便在何处，组的概念方便在于其自动化上：
# 比如 windows 上的权限组，某用户需要 admin 权限时，是将自己加入到 administrator 的组里面，这个组内的用户将会自动获得 admin 权限
# 再比如有几十个角色，需要赋给 几百个人，这时候就可以将这些角色编成一个角色组，加到这个角色组中的用户都自动获得这个组里全部的权限
# 使用用户组是，是将某个角色的权限赋给这个组里面的所有人，比如省行用户组内的所有用户自动获得 admin 权限
# 由上面我们可以开始设计表
# 自动行为需要一个 trigger 的时机，最好只在 role_group_admin、role、user 三个表发生 增删改 的时候，会自动的检查 三个表
# 对于 role 的删、改要涉及到 role_group_admin.roles 的删、改
# 对于 user 的删、改要涉及到  role_group_admin.users 的删、改
# role_group_admin 内 roles、users 的增删改都要求 检查对于的 role、user 表是否存在对应值
# 注意 角色组 跟 用户组 其实可以使用一种表来表达，但是为了简单的区分，最好有不同的名字，也不要混用
# 角色组跟用户组主要体现在操作思路流程的不同上，角色组先建立一堆角色的集合，然后在考虑加入用户，用户组则相反。
# 这两种场景都十分常见，并且不是任何操作者都可以立刻意识到二者的一致性，操作人只是往往是想给一堆用户进行分组，或者想给一堆角色进行分组开始思考的，因此最好区分开来
# 区分开来的两种表正好直接等于两种常见思路，而不需要任何的转换。
# 注意 组 不会影响到继承树的权限，是独立计算的，比如 b 继承自 a，a 加入了 admin 的权限组，b 不会因此获得任何变更。
# 如果是给 a 的 角色用户关联表 添加了 admin 权限，那么 b 就会因为继承关系获得 admin

用户组还可以用来划分数据权限，


前端的实现有多种，一种是将渲染页面的
权限交由后端过滤，前端只负责展示： 前端直接根据后端返回的 menuList 生成 route
后端只返回数据，前端负责过滤（不安全）：前端根据后台返回的 menuList, permissionMenuList 来设计前端的页面 Router


周同学（User）是某 SCI 杂志的审稿人（Role），职责之一是在系统中审核论文（Authority）。在审稿过程（Session）中，当他认为某篇论文（Resource）达到了可以公开发表标准时，就会在后台点击通过按钮（Operation）来完成审核。

本质上，角色是对多种用户的解耦，资源就是对多种资源类型的解耦

菜单树的设计：
菜单本质上是一个树的概念，表达一棵树可以使用很多种方法，由于菜单树几乎不更新，增删改是很少的，这里采用 ClosureTable 的实现方式。
既然表达是结构是树的话，就要考虑一下是支持多棵树还是单颗树，这里的根节点菜单可能有很多个，因此支持多棵树是比较好的。
支持多棵树的话，就要有区分多棵树根节点的方法，同时还要标示出那些节点属于那颗树。

使用 type 来区分是否为根节点，
type=l1:menu:

因此我

current，取当前节点下一级时，current 相当于 parent：where parent=current and deepth=1
取上一级时 current 相当于 child：where child=current and deepth=1



一共有三种权限验证的方式

1、根据是否有此角色来判断
2、根据是否有此权限表达式来判断，比如 xxx.xxx.delete，一般用来表达角色表之类属性

资源的获取：
资源的获取可以从权限表中获得，权限与资源是 1:N 的关系


数据权限的问题：
你能访问页面，说明你对这个页面可读。
但是这个页面会返回什么范围内的数据是个问题。

你能看见新增按钮，说明你能新增，这一块由前端控制，不太安全

ruoyi 框架中的部门跟岗位本质上都是用户组。
一般情况下
有个简单的区分方法，如果是用户组，那就需要在加入用户时提供加入某个用户组的选项，这些选择不管叫什么名，本质上都是用户组的概念，用于对用户进行一个范围的划分。
对应的，角色就是在添加角色时要提供快捷加入某个角色组的选项。

资源分组问题，manu、page、btn 本质上是一组的，特别是在资源多了的情况下，就会需要资源分组了。

# 从头捋一捋：
## 用户登录场景：
1. 前端登录
2. 后端获取用户的所有角色，在从角色组、用户组获取额外的角色，然后根据这些角色去获取所有权限，然后根据权限所指向的资源去取 type 为 menu、page、btn 的数据，并将其构建为 菜单树 返回给前端。
3. 前端获得了用户的 角色、权限、可用的菜单树，根据菜单树构建 路由表，并将 角色、权限 的数据放到 数据中心 中去分发。

## 新增角色场景（数据权限）：
前端访问角色页面，后端取出该用户所持有的资源中包含了 type 为 role 且 el 解析的末尾存在 r 的所有数据，并根据资源的 id 去查询到对于 role 表的数据，返回给前端。
> 规范了返回的范围

前端根据权限是否包含 role:btn:c 判断是否要显示新增按钮
前端点击新增并填写 角色姓名、显示顺序、角色父级（可选，可为该用户的全部角色，不建议实现）、可用的菜单权限（范围为该用户所持有的菜单、页面、按钮）
点击新增发送，后端取出该用户所持有的资源中包含了 type 为 role 且 el 解析的末尾存在 c 的数据，并将新增的角色放到 role 表和、资源表
> 规范了新增的范围

因此这个系统的设计中，角色分配角色，只能权限越分越小。



## 新增用户场景
访问用户页面，