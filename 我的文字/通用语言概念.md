# 通用核心概念
这里是语言之间通用的核心概念。
在我看来，编程概念的出现只有以下几个目的：
1. 精简编写时的代码
2. 提高安全性
3. 提高性能


## 

## 泛型
泛型的出现满足了目的“精简编写时的代码”和“类型安全”，但它并不会提升性能。
泛型，其实就相当于对数据的类型进行编程。

如果没有泛型，那么程序员就要自行维护类型系统，这对于小项目或者只有一个人的项目是没问题的。但对于大型项目而言，无法保证所有人都遵守规约也无法保证所有人都处于同一水平，同样也无法保证会不会有人往一个只有 u32 的数组中添加一个 i32。
种错误几乎无法调试的出来，因为只有在 i32 发生溢出时才会导致 BUG。


泛型是很多静态类型语言的语法糖：
* C++
* Java
* Rust

之所以是语法糖，是因为这些泛型最终会被编译器编译成对应类型的代码。
也因为是语法糖，所以可以是不必要的，这也是 Go1 不添加泛型的原因。
> 语法糖只是对于程序员友好，对于程序本身没有影响。


## 静态编译、动态取值
这个跟 const 有关，很多语法都是为了解决这个问题而出现的，静态编译的效率是最高的

最常见的就是用常量（const）作为静态数组的初始化常量了。

还要考虑到函数。

## 混型
混型随着时光的飞逝已经被赋予了不同的意味，但是混型的基本概念是他能够让多个类产生一个能代表所有类型的混型。
混型中的一个价值就是它能够跨越多个类使用特性和行为的能力。假如你想改变混型中的某些东西，那些改变将被应用在所有类中混型被用到的东西。正因为此，混型颇有AOP的味道，面向方面编程常被用来解决混型的问题。

这也是为什么 Golang、Rust 中都没有对象这个概念，因为面向对象有时不仅没有解决问题，甚至还带来了更多的问题跟学习成本。

> Go-接收器、Rust-trait系统

## 装饰器
这个本来是一种设计模式，但是这种设计模式实在太好用了，以至于被加入到语言特性中去。
> 但请注意，这里讲的是作为语言特性的装饰器。

装饰器在这里我指的更多是一种概念，各个语言的实现可能是不同的

比如 Java 的叫注解，其实是编译器在加注解的地方对源代码进行加工来实现类似装饰器的功能。
而 Python、EcmaScript、Rust 等语言的装饰器则是一种函数式设计的思路，虽然也要加工代码，带核心是借助函数作为一等公民来办到的。

## 迭代器
迭代器的出现满足了目的“精简编写时的代码”和“提高性能”。
这个原本也是一种设计模式。
这里的提高性能其实指的是节约了内存，





