* [跟我一起写Makefile](https://seisman.github.io/how-to-write-makefile/index.html)
* [Docs of make](https://www.gnu.org/software/make/manual/)

* [makefile 与 JS](https://zhuanlan.zhihu.com/p/34284231)

## C 的工程化工具

各种语言的工程化工具层出不穷：

* JS 的 Webpack、Parcel、Gulp、
* Java 的 Maven、Gradle
* C/C++ 的 CMake、QMake(QT)、make(GNU)、nmake(VC++)
* 跨语言的 Jenkins、Travis

其目的跟意义都是为了简化我们在开发大型程序时的工作量，比如自动测试、自动编译、仅编译最新源码等等功能。



所有工程化的工具全部都可以被 bash 来替代，但是对应的专业工具会带来更佳的使用体验跟智能的报错。

makefile 就是最早期的工程化工具，其跟 bash 高度相似，可以说当初只是设计出了一个比使用 bash 来做工程化要更方便的工具而已，也因此继承了一些 bash 中反人类的特质，跟现代的工程化工具不可同日而语。

> 反人类的意思是有些地方不要去思考 makefile 为什么要这样写。



由于 Makefile 几乎支撑起了早期全部的大型项目，所以 Makefile 直接表明了一个 C 程序员是否具备完成大型工程的能力。



makefile关系到了整个工程的编译规则。一个工程中的源文件不计其数，并且按类型、功能、模块分 别放在若干个目录中，makefile 定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译， 哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 makefile 就像一个 Shell 脚本一样，其中能直接执行操作系统的命令。



> makefile 其实并不限定于语言，由于可以直接执行 bash 它其实是一个跨语言的工程化工具。

## 编译与链接



无论是C还是C++，首先要把源文件编译成中间 代码文件，在Windows下也就是 `.obj` 文件，UNIX下是 `.o` 文件，即Object File，这个动 作叫做编译（compile）。然后再把大量的Object File合成执行文件，这个动作叫作链接（link）。

需要告诉编译器头文 件的所在位置（头文件中应该只是声明，而定义应该放在C/C++文件中），只要所有的语法正确，编译器就 可以编译出中间目标文件。一般来说，每个源文件都应该对应于一个中间目标文件（ `.o` 文件或 `.obj` 文件）。

在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显 地指出中间目标文件名，这对于编译很不方便。所以，我们要给中间目标文件打个包，在Windows下这种包 叫“库文件”（Library File），也就是 `.lib` 文件，在UNIX下，是Archive File，也就是 `.a` 文件。

总结一下，源文件首先会生成中间目标文件，再由中间目标文件生成执行文件。



## GCC 的基本操作

cc -c a_func.c a_func.h

会生成一个 .o 和一个 .h.gch 文件.



.h.gch 文件相当于 GCC 对头文件做的一个缓存，在默认情况下 gch 不会因为头文件的更新而更新此缓存，从而在编译过程中形成一个不容易发现的坑。**建议将此文件加入 clean 中**。





## makefile 的语法

```makefile
target ... : prerequisites ...
    command
    ...
    ...
```

**target：可以是一个object file（目标文件），也可以是一个执行文件，还可以是一个标签（label）。对 于标签这种特性，在后续的“伪目标”章节中会有叙述。**

**prerequisites：生成该target所依赖的文件和/或target。**

**command：对此 target 要执行的 bash 命令。**

  

反斜杠（ `\` ）是换行符的意思。这样比较便于makefile的阅读。



在这个makefile中，目标文件（target）包含：执行文件edit和中间目标文件（ `*.o` ），依赖文 件（prerequisites）就是冒号后面的那些 `.c` 文件和 `.h` 文件。每一个 `.o` 文件都有 一组依赖文件，而这些 `.o` 文件又是执行文件 `edit` 的依赖文件。依赖关系的实质就是说明了目 标文件是由哪些文件生成的，换言之，目标文件是哪些文件更新的。



**command 行的开头一定要是一个 `Tab` 键，注意不要被编辑器自动转换成空格了。**

每一个 target 都可以单独运行，运行时就相当于运行了他的 common，也可以直接 make，会自动将第一个  target 作为运行目标，如果其依赖有新的修改就自动运行对应 common。



至于像 clean 这种 target，由于没有任何依赖，所以只能手动运行，相当于功能函数。

> 当然，请不要把 clean 放到第一位，不然 make 像是空气





make 的自动推导，类似于约定大于配置，但滥用这种能力会使得原本清晰明了的构建过程变得复杂和隐晦，增加阅读难度，因此使用不太隐晦的地方是最好的。



`.PHONY` 表示 `clean` 是一个“伪目标”。



## Makefile里有什么？

Makefile里主要包含了五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。

1. 显式规则。显式规则说明了如何生成一个或多个目标文件。这是由Makefile的书写者明显指出要生成的 文件、文件的依赖文件和生成的命令。
2. 隐晦规则。由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较简略地书写 Makefile，这是由make所支持的。
3. 变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点像你C语言中的 宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。
4. 文件指示。其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中 的include一样；另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一 样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。
5. 注释。Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用 `#` 字符，这个就 像C/C++中的 `//` 一样。如果你要在你的Makefile中使用 `#` 字符，可以用反斜杠进行 转义，如： `\#`  。

最后，还值得一提的是，在Makefile中的命令，必须要以 `Tab` 键开始。



## 环境变量MAKEFILES

如果你的当前环境中定义了环境变量 `MAKEFILES` ，那么，make会把这个变量中的值做一个类似于 `include` 的动作。这个变量中的值是其它的Makefile，用空格分隔。只是，它和 `include` 不 同的是，从这个环境变量中引入的Makefile的“目标”不会起作用，如果环境变量中定义的文件发现 错误，make也会不理。

但是在这里我还是建议不要使用这个环境变量，因为只要这个变量一被定义，那么当你使用make时， 所有的Makefile都会受到它的影响，这绝不是你想看到的。在这里提这个事，只是为了告诉大家，也许 有时候你的Makefile出现了怪事，那么你可以看看当前环境中有没有定义这个变量。



## make是如何工作的

在默认的方式下，也就是我们只输入 `make` 命令。那么，

1. make会在当前目录下找名字叫“Makefile”或“makefile”的文件。
2. 如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“edit”这个 文件，并把这个文件作为最终的目标文件。
3. 如果edit文件不存在，或是edit所依赖的后面的 `.o` 文件的文件修改时间要比 `edit` 这个 文件新，那么，他就会执行后面所定义的命令来生成 `edit` 这个文件。
4. 如果 `edit` 所依赖的 `.o` 文件也不存在，那么make会在当前文件中找目标为 `.o` 文件 的依赖性，如果找到则再根据那一个规则生成 `.o` 文件。（这有点像一个堆栈的过程）
5. 当然，你的C文件和H文件是存在的啦，于是make会生成 `.o` 文件，然后再用 `.o` 文件生 成make的终极任务，也就是执行文件 `edit` 了。

这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。



于是在我们编程中，如果这个工程已被编译过了，当我们修改了其中一个源文件，比如 `file.c` ， 那么根据我们的依赖性，我们的目标 `file.o` 会被重编译（也就是在这个依性关系后面所定义的命令）， 于是 `file.o` 的文件也是最新的啦，于是 `file.o` 的文件修改时间要比 `edit` 要新，所 以 `edit` 也会被重新链接了（详见 `edit` 目标文件后定义的命令）。

而如果我们改变了 `command.h` ，那么， `kdb.o` 、 `command.o` 和 `files.o` 都 会被重编译，并且， `edit` 会被重链接。



GNU的make工作时的执行步骤如下：（想来其它的make也是类似）

1. 读入所有的Makefile。
2. 读入被include的其它Makefile。
3. 初始化文件中的变量。
4. 推导隐晦规则，并分析所有规则。
5. 为所有的目标文件创建依赖关系链。
6. 根据依赖关系，决定哪些目标要重新生成。
7. 执行生成命令。

1-5步为第一个阶段，6-7为第二个阶段。第一个阶段中，如果定义的变量被使用了，那么，make会把其展 开在使用的位置。但make并不会完全马上展开，make使用的是拖延战术，如果变量出现在依赖关系的规则 中，那么仅当这条依赖被决定要使用了，变量才会在其内部展开。

## makefile 的一些有用功能和片段

