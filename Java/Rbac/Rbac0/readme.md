
关键词：
* 权限信息


用户登录时，在 AuthInterceptor 登录并获取其 权限信息：用户基本信息、角色、权限.
同时为了支持超级管理员，在入口的鉴权拦截器检测到是 admin 时，就扫描全部权限并添加给 admin 用户。
在这里可以使用缓存权限来加速，但这样会有缓存一致性问题。

用户登录后，访问 url，在 AuthInterceptor 登录，然后将其 权限信息 持久化到 request 的 scope 中
> 这里如果使用 jwt 那就是解析 jwtToken 然后持久化到 request 的 scope 中
> 如果是 session 那就是解析 token 然后持久化到 request 的 scope 中


做权限判断时，一根据 角色 来取到 该角色的权限表 然后在根据权限表有没有这个 权限 来进行判断
权限表达式可以自己设计，一般从左至右是从大到小的顺序，比如 模块:功能:CURD、菜单:按钮:CRUD
这样权限表达式就会被区分为好几种，使用时要注意区分。

Rbac0 其权限是由关联表来赋予的，比如要赋予某个角色权限时只需要更新 角色权限关联表 即可
用户登录，查询该用户所持有的角色，根据角色去取该用户所持有的权限表达式，返回角色跟权限表达式。
前端得到角色跟权限表达式，可以使用 hasRole hasPermission 来决定是否能够访问资源
权限往往有两层，第一层是资源的可见性这个是由于前后端带来的，以前模板引擎是不会有这个的
第二层是资源的 crud，这个是真正的后端权限，决定了该角色能对这个资源做什么
由 第一层 跟 第二层 我们就能得出一个有趣的问题，那就是如果只在前端实现了安全性会怎样？
也就是不想前后端都实现一遍对资源的 curd 判断，只在前端做了显示不显示的判断，那样就会导致安全问题